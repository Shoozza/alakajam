<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/highscore-service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/highscore-service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/**
 * Service for importing entries from third-party websites
 *
 * @module services/highscore-service
 */

const models = require('../core/models')
const db = require('../core/db')
const enums = require('../core/enums')
const forms = require('../core/forms')
const fileStorage = require('../core/file-storage')
const eventTournamentService = require('./event-tournament-service')

module.exports = {
  findHighScores,
  findHighScoresMap,

  findEntryScore,
  findEntryScoreById,
  findUserScoresMapByEntry,

  createEntryScore,
  submitEntryScore,
  setEntryScoreActive,
  deleteEntryScore,
  deleteAllEntryScores,

  isExternalProof,

  refreshEntryRankings
}

async function findHighScores (entry, options = {}) {
  let query = models.EntryScore.where('entry_id', entry.get('id'))
  if (!options.withSuspended) {
    query.where('active', true)
  }
  query.orderBy('score', _rankingDir(entry))

  let fetchOptions = {
    withRelated: ['user']
  }
  if (options.fetchAll) {
    return query.fetchAll(fetchOptions)
  } else {
    fetchOptions.pageSize = 10
    return query.fetchPage(fetchOptions)
  }
}

async function findHighScoresMap (entries) {
  entries = entries.models || entries // Accept collections or arrays

  let highScoresMap = {}
  for (let entry of entries) {
    highScoresMap[entry.get('id')] = await findHighScores(entry)
  }
  return highScoresMap
}

async function createEntryScore (userId, entryId) {
  let entryScore = new models.EntryScore({
    user_id: userId,
    entry_id: entryId
  })
  await entryScore.load(['user'])
  return entryScore
}

async function findEntryScore (userId, entryId) {
  if (userId &amp;&amp; entryId) {
    return models.EntryScore.where({
      user_id: userId,
      entry_id: entryId
    })
      .fetch({ withRelated: ['user'] })
  } else {
    return null
  }
}

async function findUserScoresMapByEntry (userId, entries) {
  entries = entries.models || entries // Accept collections or arrays

  if (userId &amp;&amp; entries) {
    let entriesToScore = {}
    let entryScores = await models.EntryScore
      .where('user_id', userId)
      .where('entry_id', 'in', entries.map(entry => entry.get('id')))
      .fetchAll({ withRelated: ['user'] })
    for (let entry of entries) {
      entriesToScore[entry.get('id')] = entryScores.find(score => score.get('entry_id') === entry.get('id'))
    }
    return entriesToScore
  } else {
    return null
  }
}

async function findEntryScoreById (id, options = {}) {
  return models.EntryScore.where('id', id)
    .fetch({
      withRelated: options.withRelated || ['user']
    })
}

/**
 * @return any errors, or the updated entry score (ie. with the ranking set)
 */
async function submitEntryScore (entryScore, entry) {
  if (!entryScore || !entry) {
    return { error: 'Internal error (missing score information)' }
  }
  if (entryScore.get('score') === 0) {
    return { error: 'Invalid score' }
  }

  if (entry.get('status_high_score') !== enums.ENTRY.STATUS_HIGH_SCORE.OFF) {
    if (entryScore.hasChanged()) {
      // Check ranking before accepting proof-less score
      if (!entryScore.get('proof')) {
        let higherScoreCount = await models.EntryScore
          .where('entry_id', entry.get('id'))
          .where('score', _rankingOperator(entry), entryScore.get('score'))
          .count()
        let ranking = parseInt(higherScoreCount) + 1
        if (ranking &lt;= 10) {
          return { error: 'Pic or it didn\'t happen! You need a screenshot to get in the Top 10 :)' }
        }
      }

      // Save score
      entryScore.set('active', true)
      await entryScore.save()

      // Refresh rankings
      let updatedEntryScore = await refreshEntryRankings(entry, entryScore)
      return updatedEntryScore || entryScore
    } else {
      return entryScore
    }
  } else {
    return { error: 'High scores are disabled on this entry' }
  }
}

async function setEntryScoreActive (id, active) {
  let entryScore = await findEntryScoreById(id, { withRelated: ['entry.details'] })
  if (entryScore &amp;&amp; entryScore.get('active') !== active) {
    entryScore.set('active', active)
    await entryScore.save()
    await refreshEntryRankings(entryScore.related('entry'), entryScore,
      { statusTournamentAllowed: [enums.EVENT.STATUS_TOURNAMENT.PLAYING, enums.EVENT.STATUS_TOURNAMENT.CLOSED] })
  }
}

async function deleteEntryScore (entryScore, entry) {
  if (!isExternalProof(entryScore)) {
    fileStorage.remove(entryScore.get('proof'))
  }
  let triggeringUserId = entryScore.get('user_id')
  await entryScore.destroy()
  await refreshEntryRankings(entry, null, { triggeringUserId })
}

async function deleteAllEntryScores (entry) {
  await db.knex('entry_score')
    .where('entry_id', entry.get('id'))
    .delete()
  await refreshEntryRankings(entry)
}

async function refreshEntryRankings (entry, triggeringEntryScore = null, options = {}) {
  let updatedEntryScore = null
  let impactedEntryScores = []

  let scores = await models.EntryScore
    .where('entry_id', entry.get('id'))
    .orderBy('score', _rankingDir(entry))
    .orderBy('updated_at')
    .fetchAll()

  await db.transaction(async function (t) {
    let ranking = 1
    for (let score of scores.models) {
      if (score.get('ranking') !== ranking) {
        score.set('ranking', ranking)
        score.save(null, { transacting: t })
        if (score.get('active')) {
          impactedEntryScores.push(score)
        }
      }
      if (score.get('active')) {
        ranking++
      }

      if (triggeringEntryScore &amp;&amp; score.get('id') === triggeringEntryScore.get('id')) {
        updatedEntryScore = score
      }
    }
  })

  // Update high score count
  let entryDetails = entry.related('details')
  if (entryDetails.get('high_score_count') !== scores.models.length) {
    await entryDetails.save({ 'high_score_count': scores.models.length }, { patch: true })
  }

  // Refresh active tournament scores
  let activeTournamentEvent = await eventTournamentService.findActiveTournamentPlaying(entry.get('id'), options)
  if (activeTournamentEvent) {
    let triggeringUserId = options.triggeringUserId || (triggeringEntryScore ? triggeringEntryScore.get('user_id') : null)
    eventTournamentService.refreshTournamentScores(module.exports, activeTournamentEvent, triggeringUserId, impactedEntryScores, options)
  }

  if (updatedEntryScore) {
    await updatedEntryScore.load(['user'])
  }
  return updatedEntryScore
}

function isExternalProof (entryScore) {
  return forms.isURL(entryScore.get('proof'))
}

function _rankingDir (entry) {
  return entry.get('status_high_score') === enums.ENTRY.STATUS_HIGH_SCORE.REVERSED ? 'ASC' : 'DESC'
}

function _rankingOperator (entry) {
  return entry.get('status_high_score') === enums.ENTRY.STATUS_HIGH_SCORE.REVERSED ? '&lt;' : '>'
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-core_cache.html">core/cache</a></li><li><a href="module-core_constants.html">core/constants</a></li><li><a href="module-core_db.html">core/db</a></li><li><a href="module-core_enums.html">core/enums</a></li><li><a href="module-core_file-storage.html">core/file-storage</a></li><li><a href="module-core_forms.html">core/forms</a></li><li><a href="module-core_log.html">core/log</a></li><li><a href="module-core_middleware.html">core/middleware</a></li><li><a href="module-core_models.html">core/models</a></li><li><a href="module-services_event-import-service.html">services/event-import-service</a></li><li><a href="module-services_event-rating-service.html">services/event-rating-service</a></li><li><a href="module-services_event-service.html">services/event-service</a></li><li><a href="module-services_event-theme-service.html">services/event-theme-service</a></li><li><a href="module-services_event-tournament-service.html">services/event-tournament-service</a></li><li><a href="module-services_highscore-service.html">services/highscore-service</a></li><li><a href="module-services_mail-service.html">services/mail-service</a></li><li><a href="module-services_notification-service.html">services/notification-service</a></li><li><a href="module-services_platform-service.html">services/platform-service</a></li><li><a href="module-services_post-service.html">services/post-service</a></li><li><a href="module-services_security-service.html">services/security-service</a></li><li><a href="module-services_session-service.html">services/session-service</a></li><li><a href="module-services_setting-service.html">services/setting-service</a></li><li><a href="module-services_user-service.html">services/user-service</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createTag">createTag</a></li><li><a href="global.html#fetchById">fetchById</a></li><li><a href="global.html#fetchByIds">fetchByIds</a></li><li><a href="global.html#searchTags">searchTags</a></li><li><a href="global.html#updateEntryTags">updateEntryTags</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Apr 23 2018 09:52:09 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
