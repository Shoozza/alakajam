<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/models.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/models.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

/**
 * Bookshelf models
 *
 * @module core/models
 */

const slug = require('slug')
const bookshelf = require('./db')

let modelPrototype = bookshelf.Model.prototype

// TODO Set up BaseModel to make code more concise

/**
 * Setting model
 *
 * | type | name | description
 * |--    |--    |--
 * | string | key | Primary key
 * | string | value | Setting value (max size: 10000)
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.Setting = bookshelf.model('Setting', {
  tableName: 'setting',
  idAttribute: 'key',
  hasTimestamps: true
})

// ===============================================================
// USERS
// ===============================================================

/**
 * User model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | string | name | User name (must be unique, not null)
 * | string | title |
 * | string | email | (not null)
 * | string | avatar |
 * | string | is_mod |
 * | string | is_admin |
 * | string | password | (not null)
 * | string | password_salt | (not null)
 * | dateTime | notifications_last_read |
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 * | boolean | disallow_anonymous | Disallow this user to post anonymous comments
 */
module.exports.User = bookshelf.model('User', {
  tableName: 'user',
  idAttribute: 'id',
  hasTimestamps: true,

  details: function () {
    return this.hasOne('UserDetails', 'user_id')
  },
  roles: function () {
    return this.hasMany('UserRole', 'user_id')
  },
  comments: function () {
    return this.hasMany('Comment', 'user_id')
  },
  entryScores: function () {
    return this.hasMany('EntryScore', 'user_id')
  },
  tournamentScores: function () {
    return this.hasMany('TournamentScore', 'user_id')
  }
}, {
  // Cascading
  dependents: ['details', 'roles', 'entryScores', 'tournamentScores']
})

/**
 * User Details model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | user_id | User ID (must be unique)
 * | string | body | User bio (max size : 100000)
 * | string | social_links | Social links JSON `{website, twitter}` (max size : 1000)
 */
module.exports.UserDetails = bookshelf.model('UserDetails', {
  tableName: 'user_details',
  idAttribute: 'id',

  // Relations

  user: function () {
    return this.belongsTo('User', 'user_id')
  },

  // Listeners

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    attrs = attrs || {}
    attrs['social_links'] = attrs['social_links'] || []
    return attrs
  },
  parse: function parse (attrs) {
    if (attrs['social_links']) attrs['social_links'] = JSON.parse(attrs['social_links'])
    return attrs
  },
  format: function format (attrs) {
    if (attrs &amp;&amp; attrs['social_links']) attrs['social_links'] = JSON.stringify(attrs['social_links'])
    return attrs
  }
})

/**
 * User Role model
 *
 * | type | name | description
 * |--    |--    |--
 * | integer (increments) | id | Primary key
 * | integer | user_id | User ID (not null)
 * | string | user_name | Local copy of the user name (not null)
 * | string | user_title | Local copy of the user title
 * | integer | node_id | ID of the target node (not null)
 * | string | node_type | Type of the target node ('entry' or 'post', not null)
 * | string | permission | Permission: 'read', 'write', 'manage' (not null)
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.UserRole = bookshelf.model('UserRole', {
  tableName: 'user_role',
  idAttribute: 'id',
  hasTimestamps: true,

  user: function () {
    return this.belongsTo('User', 'user_id')
  },
  node: function () {
    return this.morphTo('node', ['node_type', 'node_id'], 'Entry', 'Post')
  }
})

// ===============================================================
// EVENTS
// ===============================================================

/**
 * Event model
 *
 * | type | name | description
 * |--    |--    |--
 * | integer | id | ID
 * | string | name | Name (used in the URL, not null). Must have a hyphen to prevent clashing other root URLs.
 * | string | title | Title (not null)
 * | string | display_dates | The event dates, for display only
 * | string | display_theme | The event theme, for display only
 * | string | logo | Path to a logo picture
 * | string | status | General status: 'pending', 'open' or 'closed' (not null)
 * | string | status_rules | Event rules status: 'disabled', 'off', or a post ID (not null)
 * | string | status_theme | Theme voting status: 'disabled', 'off', 'voting', 'shortlist', 'closed', 'results', or a post ID (not null)
 * | string | status_entry | Entry submission status: 'off', 'open', 'open_unranked' or 'closed' (not null)
 * | string | status_results | Event results status: 'disabled', 'off', 'voting', 'results', or a post ID (not null)
 * | string | status_tournament | Event tournament status: 'disabled', 'off', 'submission', 'playing', 'closed', 'results'
 * | string | coutdown_config | Home page countdown JSON: `{date, phrase, enabled}`
 * | string | divisions | Divisions info: `{"name": "description"}`
 * | integer | entry_count | Total number of entries in the event.
 * | date | published_at | Publication date. If empty, the event is a draft.
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.Event = bookshelf.model('Event', {
  tableName: 'event',
  idAttribute: 'id',
  hasTimestamps: true,

  // Relations

  details: function () {
    return this.hasOne('EventDetails', 'event_id')
  },
  entries: function () {
    return this.hasMany('Entry', 'event_id')
  },
  tournamentEntries: function () {
    return this.hasMany('TournamentEntry', 'event_id')
  },

  // Listeners

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    attrs = attrs || {}
    attrs['countdown_config'] = attrs['countdown_config'] || {}
    attrs['cron_config'] = attrs['cron_config'] || {}
    attrs['divisions'] = attrs['divisions'] || {}
    return attrs
  },
  parse: function parse (attrs) {
    if (attrs['countdown_config']) attrs['countdown_config'] = JSON.parse(attrs['countdown_config'])
    if (attrs['cron_config']) attrs['cron_config'] = JSON.parse(attrs['cron_config'])
    if (attrs['divisions']) attrs['divisions'] = JSON.parse(attrs['divisions'])
    return attrs
  },
  format: function format (attrs) {
    if (attrs &amp;&amp; attrs['countdown_config']) attrs['countdown_config'] = JSON.stringify(attrs['countdown_config'])
    if (attrs &amp;&amp; attrs['cron_config']) attrs['cron_config'] = JSON.stringify(attrs['cron_config'])
    if (attrs &amp;&amp; attrs['divisions']) attrs['divisions'] = JSON.stringify(attrs['divisions'])
    return attrs
  }
}, {
  // Cascading
  dependents: ['details', 'entries']
})

/**
 * Event Details model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | event_id | Event ID (not null)
 * | integer | category_titles | Category names (JSON: [name])
 * | integer | theme_count | Number of theme ideas submitted
 * | integer | active_theme_count | Number of active themes
 * | integer | theme_vote_count | Number of theme votes
 * | string | banner | Path to a banner picture
 * | string | division_counts | Number of entries by division: {"name": count...}
 * | string | shortlist_elimination | Config for shortlist eliminations phase: (JSON: {"start": date, "delay": number in minutes, "body": html}
 * | string | links | Config for a list of special pages to link to: (JSON: [{"title": string, "link": string, "icon": string}]
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.EventDetails = bookshelf.model('EventDetails', {
  tableName: 'event_details',
  idAttribute: 'id',
  hasTimestamps: true,

  // Listeners

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    attrs = attrs || {}
    attrs['category_titles'] = attrs['category_titles'] || []
    attrs['division_counts'] = attrs['division_counts'] || []
    attrs['shortlist_elimination'] = attrs['shortlist_elimination'] || {}
    attrs['links'] = attrs['links'] || {}
    return attrs
  },
  parse: function parse (attrs) {
    if (attrs['category_titles']) attrs['category_titles'] = JSON.parse(attrs['category_titles'])
    if (attrs['division_counts']) attrs['division_counts'] = JSON.parse(attrs['division_counts'])
    if (attrs['shortlist_elimination']) attrs['shortlist_elimination'] = JSON.parse(attrs['shortlist_elimination'])
    if (attrs['links']) attrs['links'] = JSON.parse(attrs['links'])
    return attrs
  },
  format: function format (attrs) {
    if (attrs &amp;&amp; attrs['category_titles']) attrs['category_titles'] = JSON.stringify(attrs['category_titles'])
    if (attrs &amp;&amp; attrs['division_counts']) attrs['division_counts'] = JSON.stringify(attrs['division_counts'])
    if (attrs &amp;&amp; attrs['shortlist_elimination']) attrs['shortlist_elimination'] = JSON.stringify(attrs['shortlist_elimination'])
    if (attrs &amp;&amp; attrs['links']) attrs['links'] = JSON.stringify(attrs['links'])
    return attrs
  },

  event: function () {
    return this.belongsTo('Event', 'event_id')
  }
})

/**
 * Entry model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | event_id | Event ID (can be null in case of an external entry)
 * | string | event_name | Name (used in the URL, can be null in case of an external entry)
 * | string | external_event | External event title (if not an Alakajam! game, ie. event_id is null)
 * | string | name | (not null)
 * | string | title | (not null)
 * | string | description | (max size: 2000)
 * | string | links | JSON Array : [{url, title}]
 * | string | platforms | JSON Array : [platform]
 * | string | pictures | JSON Array : [path]
 * | string | division | "solo"/"team"/"unranked" (not null)
 * | decimal | feedback_score | ([-999.999;999.999], defaults to 100, not null)
 * | dateTime | published_at |
 * | integer | comment_count | (not null)
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 * | boolean | allow_anonymous | Are anonymous comments allowed on this entry?
 * | string | status_high_score | High score enablement status ('off', 'normal', 'reversed')
 */
module.exports.Entry = bookshelf.model('Entry', {
  tableName: 'entry',
  idAttribute: 'id',
  hasTimestamps: true,

  // Relations

  details: function () {
    return this.hasOne('EntryDetails', 'entry_id')
  },
  event: function () {
    return this.belongsTo('Event', 'event_id')
  },
  userRoles: function () {
    return this.morphMany('UserRole', 'node', ['node_type', 'node_id'])
  },
  comments: function () {
    return this.morphMany('Comment', 'node', ['node_type', 'node_id'])
  },
  entryPlatforms: function () {
    return this.hasMany('EntryPlatform', 'entry_id')
  },
  votes: function () {
    return this.hasMany('EntryVote', 'entry_id')
  },
  invites: function () {
    return this.hasMany('EntryInvite', 'entry_id')
  },
  tags: function () {
    return this.belongsToMany('Tag', 'entry_tag', 'entry_id', 'tag_id')
  },
  posts: function () {
    return this.hasMany('Post', 'entry_id')
  },
  scores: function () {
    return this.hasMany('EntryScore', 'entry_id')
  },

  // Listeners

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    this.on('saving', function (model, attrs, options) {
      model.set('name', slug(model.get('title') || '').toLowerCase() || 'unnamed')
    })
    attrs = attrs || {}
    attrs.links = attrs.links || []
    attrs.pictures = attrs.pictures || []
    attrs.platforms = attrs.platforms || []
    return attrs
  },
  parse: function parse (attrs) {
    if (attrs.links) attrs.links = JSON.parse(attrs.links)
    if (attrs.pictures) attrs.pictures = JSON.parse(attrs.pictures)
    if (attrs.platforms) attrs.platforms = JSON.parse(attrs.platforms)
    return attrs
  },
  format: function format (attrs) {
    if (attrs &amp;&amp; attrs.links) attrs.links = JSON.stringify(attrs.links)
    if (attrs &amp;&amp; attrs.pictures) attrs.pictures = JSON.stringify(attrs.pictures)
    if (attrs &amp;&amp; attrs.platforms) attrs.platforms = JSON.stringify(attrs.platforms)
    return attrs
  },

  // Helpers

  sortedUserRoles: function () {
    return this.related('userRoles').sortBy(function (userRole) {
      // List owners first, otherwise sort alphabetically
      if (userRole.get('permission') === 'manage') {
        return ' ' + userRole.get('user_title')
      } else {
        return userRole.get('user_title')
      }
    })
  }

}, {
  // Cascading
  dependents: ['details', 'comments', 'entryPlatforms', 'votes', 'invites', 'tags', 'scores'] // 'userRoles' removed because of issue #93
})

/**
 * Entry Details model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | entry_id | Entry ID (not null)
 * | string | body | Detailed description (max size: 100000)
 * | string | optouts | Opted-out categories (JSON: [category_title])
 * | decimal | rating_1 .. 6 | Rating for categories 1 to 6 ([-99.999,99.999])
 * | integer | ranking_1 .. 6 | Ranking for categories 1 to 6 (max: 100000)
 * | integer | rating_count | Received rating count
 * | integer | high_score_count | Submitted scores count
 * | integer | high_score_type | 'number', 'time' or any custom text to be used as a suffix (max size: 20)
 * | integer | high_score_instructions | Markdown text to be shown when submitting a score (max size: 2000)
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.EntryDetails = bookshelf.model('EntryDetails', {
  tableName: 'entry_details',
  idAttribute: 'id',
  hasTimestamps: true,

  entry: function () {
    return this.belongsTo('Entry', 'entry_id')
  },

  // Listeners

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    attrs = attrs || {}
    attrs.optouts = attrs.optouts || []
    return attrs
  },
  parse: function parse (attrs) {
    if (attrs.optouts) attrs.optouts = JSON.parse(attrs.optouts)
    return attrs
  },
  format: function format (attrs) {
    if (attrs &amp;&amp; attrs.optouts) attrs.optouts = JSON.stringify(attrs.optouts)
    return attrs
  }

})

/**
 * Platform model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | string | name | Platform name
 */
module.exports.Platform = bookshelf.model('Platform', {
  tableName: 'platform',
  idAttribute: 'id'
})

/**
 * Entry Platform model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | entry_id | Entry ID (not null)
 * | string | platform_name | Platform name (max size: 50)
 */
module.exports.EntryPlatform = bookshelf.model('EntryPlatform', {
  tableName: 'entry_platform',
  idAttribute: 'id',

  entry: function () {
    return this.belongsTo('Entry', 'entry_id')
  },
  platform: function () {
    return this.belongsTo('Platform', 'platform_id')
  },

  // Listeners

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    attrs = attrs || {}
    return attrs
  }
})

/**
 * Tag model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | value | Tag label
 */
module.exports.Tag = bookshelf.model('Tag', {
  tableName: 'tag',
  idAttribute: 'id',

  entries: function () {
    return this.belongsToMany('Entry', 'entry_tag', 'tag_id', 'entry_id')
  },
  entryJoins: function () {
    return this.hasMany('EntryTag', 'tag_id')
  }
}, {
  // Cascading
  dependents: ['entryJoins']
})

module.exports.EntryTag = bookshelf.model('EntryTag', {
  tableName: 'entry_tag'
})

/**
 * Entry Vote model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | entry_id | Entry ID (not null)
 * | integer | event_id | Event ID (not null)
 * | integer | user_id | User ID (not null)
 * | decimal | vote_1 .. 4 | Vote for categories 1 to 4 ([-999.99,999.99])
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.EntryVote = bookshelf.model('EntryVote', {
  tableName: 'entry_vote',
  idAttribute: 'id',
  hasTimestamps: true,

  entry: function () {
    return this.belongsTo('Entry', 'entry_id')
  },
  event: function () {
    return this.belongsTo('Event', 'event_id')
  },
  user: function () {
    return this.belongsTo('User', 'user_id')
  }
})

/**
 * Entry Invite model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | entry_id | Target entry ID (not null)
 * | integer | invited_user_id | User ID of the person invited (not null)
 * | integer | invited_user_title | User title of the person invited (not null)
 * | string | permission | The offered permission (not null)
 */
module.exports.EntryInvite = bookshelf.model('EntryInvite', {
  tableName: 'entry_invite',
  idAttribute: 'id',
  hasTimestamps: true,

  entry: function () {
    return this.belongsTo('Entry', 'entry_id')
  },
  invited: function () {
    return this.belongsTo('User', 'invited_user_id')
  }
})

// ===============================================================
// THEMES
// ===============================================================

/**
 * Theme model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | event_id | Event ID (not null)
 * | integer | user_id | User ID (not null)
 * | string | title | (max size: 100, not null)
 * | string | slug | Used for detecting duplicate themes (not null)
 * | integer | score | (defaults to 0, not null)
 * | decimal | normalized_score | (defaults to 0, not null, [-9.999;9.999])
 * | decimal | ranking | rough ranking in percentage ([-9.999;9.999])
 * | integer | notes | (defaults to 0, not null)
 * | integer | reports | (defaults to 0, not null)
 * | string | status | 'active', 'out', 'banned', 'shortlist' (not null)
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.Theme = bookshelf.model('Theme', {
  tableName: 'theme',
  idAttribute: 'id',
  hasTimestamps: true,

  // Relations

  event: function () {
    return this.belongsTo('Event', 'event_id')
  },
  user: function () {
    return this.belongsTo('User', 'user_id')
  },
  votes: function () {
    return this.hasMany('ThemeVote', 'theme_id')
  }

}, {
  // Cascading
  dependents: ['votes']
})

/**
 * Theme Vote model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | theme_id | Theme ID (not null)
 * | integer | event_id | Event ID (not null)
 * | integer | user_id | User ID (not null)
 * | integer | score | (not null)
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.ThemeVote = bookshelf.model('ThemeVote', {
  tableName: 'theme_vote',
  idAttribute: 'id',
  hasTimestamps: true,

  // Relations

  theme: function () {
    return this.belongsTo('Theme', 'theme_id')
  },
  event: function () {
    return this.belongsTo('Event', 'event_id')
  },
  user: function () {
    return this.belongsTo('User', 'user_id')
  }
})

// ===============================================================
// HIGH SCORES / TOURNAMENTS
// ===============================================================

/**
 * Entry score model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | user_id | User ID (not null)
 * | integer | entry_id | Entry ID (not null)
 * | decimal | score | Score ([-999.999.999.999,999;999.999.999.999,999], not null)
 * | string | proof | URL of the proof picture or video
 * | integer | ranking | User ranking on that entry
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.EntryScore = bookshelf.model('EntryScore', {
  tableName: 'entry_score',
  hasTimestamps: true,

  // Relations

  user: function () {
    return this.belongsTo('User', 'user_id')
  },
  entry: function () {
    return this.belongsTo('Entry', 'entry_id')
  }
})

/**
 * Tournament entry model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | event_id | Tournament event ID (not null)
 * | integer | entry_id | Entry ID (not null)
 * | integer | ordering | Entry order
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.TournamentEntry = bookshelf.model('TournamentEntry', {
  tableName: 'tournament_entry',
  hasTimestamps: true,

  // Relations

  entry: function () {
    return this.belongsTo('Entry', 'entry_id')
  },
  event: function () {
    return this.belongsTo('Event', 'event_id')
  }
})

/**
 * Tournament score model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | user_id | User ID (not null)
 * | integer | event_id | Tournament event ID (not null)
 * | decimal | score | Score ([-999.999.999.999,999;999.999.999.999,999], not null)
 * | string | entry_scores | JSON caching of the entry scores used to compute the tournament score: {entryId: {score, ranking}}
 * | integer | ranking | User ranking on that tournament
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.TournamentScore = bookshelf.model('TournamentScore', {
  tableName: 'tournament_score',
  hasTimestamps: true,

  // Listeners

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    attrs = attrs || {}
    attrs['entry_scores'] = attrs['entry_scores'] || {}
    return attrs
  },
  parse: function parse (attrs) {
    if (attrs['entry_scores']) attrs['entry_scores'] = JSON.parse(attrs['entry_scores'])
    return attrs
  },
  format: function format (attrs) {
    if (attrs &amp;&amp; attrs['entry_scores']) attrs['entry_scores'] = JSON.stringify(attrs['entry_scores'])
    return attrs
  },

  // Relations

  user: function () {
    return this.belongsTo('User', 'user_id')
  },
  event: function () {
    return this.belongsTo('Event', 'event_id')
  }
})

// ===============================================================
// POSTS
// ===============================================================

/**
 * Post model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | author_user_id | Author user ID (not null)
 * | string | name | Name (used in the URL, not null)
 * | string | title | Title (not null)
 * | integer | entry_id | Entry ID
 * | integer | event_id | Event ID
 * | string | body | Post body (max size: 100000)
 * | string | special_post_type | 'announcement' or empty
 * | integer | comment_count | Number of comments made on this post
 * | dateTime | published_at | Publication time
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.Post = bookshelf.model('Post', {
  tableName: 'post',
  hasTimestamps: true,

  initialize: function initialize (attrs) {
    modelPrototype.initialize.call(this)
    this.on('saving', function (model, attrs, options) {
      this.trigger('titleChanged')
    })
    this.on('titleChanged', function () {
      this.set('name', slug(this.get('title') || '').toLowerCase())
    })
    return attrs
  },

  // Relations

  entry: function () {
    return this.belongsTo('Entry', 'entry_id')
  },
  event: function () {
    return this.belongsTo('Event', 'event_id')
  },
  author: function () {
    return this.belongsTo('User', 'author_user_id')
  },
  userRoles: function () {
    // TODO isn't it sufficient to specify either 'node' or ['node_type', 'node_id']?
    return this.morphMany('UserRole', 'node', ['node_type', 'node_id'])
  },
  comments: function () {
    return this.morphMany('Comment', 'node', ['node_type', 'node_id'])
  }
}, {
  // Cascading
  dependents: ['comments'] // 'userRoles' removed because of issue #93
})

/**
 * Comment model
 *
 * | type | name | description
 * |--    |--    |--
 * | increments | id | Primary key
 * | integer | node_id | ID of the target node (not null)
 * | string | node_type | Type of the target node ('entry' or 'post', not null)
 * | integer | user_id | Author user ID (not null)
 * | integer | parent_id | Parent comment ID
 * | string | body | Comment body (max size: 10000)
 * | integer | feedback_score | Feedback score gained through this comment (between 1 &amp; 3, not null)
 * | date | created_at | Creation time (not null)
 * | date | modified_at | Last modification time (not null)
 */
module.exports.Comment = bookshelf.model('Comment', {
  tableName: 'comment',
  hasTimestamps: true,

  // Relations

  node: function () {
    return this.morphTo('node', ['node_type', 'node_id'], 'Entry', 'Post')
  },
  user: function () {
    return this.belongsTo('User', 'user_id', 'id')
  },
  parentComment: function () {
    return this.belongsTo('Comment', 'parent_id', 'id')
  }
})
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-core_cache.html">core/cache</a></li><li><a href="module-core_constants.html">core/constants</a></li><li><a href="module-core_db.html">core/db</a></li><li><a href="module-core_enums.html">core/enums</a></li><li><a href="module-core_file-storage.html">core/file-storage</a></li><li><a href="module-core_forms.html">core/forms</a></li><li><a href="module-core_log.html">core/log</a></li><li><a href="module-core_middleware.html">core/middleware</a></li><li><a href="module-core_models.html">core/models</a></li><li><a href="module-services_event-import-service.html">services/event-import-service</a></li><li><a href="module-services_event-rating-service.html">services/event-rating-service</a></li><li><a href="module-services_event-service.html">services/event-service</a></li><li><a href="module-services_event-theme-service.html">services/event-theme-service</a></li><li><a href="module-services_event-tournament-service.html">services/event-tournament-service</a></li><li><a href="module-services_highscore-service.html">services/highscore-service</a></li><li><a href="module-services_mail-service.html">services/mail-service</a></li><li><a href="module-services_notification-service.html">services/notification-service</a></li><li><a href="module-services_platform-service.html">services/platform-service</a></li><li><a href="module-services_post-service.html">services/post-service</a></li><li><a href="module-services_security-service.html">services/security-service</a></li><li><a href="module-services_session-service.html">services/session-service</a></li><li><a href="module-services_setting-service.html">services/setting-service</a></li><li><a href="module-services_user-service.html">services/user-service</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createTag">createTag</a></li><li><a href="global.html#fetchById">fetchById</a></li><li><a href="global.html#fetchByIds">fetchByIds</a></li><li><a href="global.html#searchTags">searchTags</a></li><li><a href="global.html#updateEntryTags">updateEntryTags</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Apr 23 2018 09:52:09 GMT+0200 (Paris, Madrid (heure d’été))
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
